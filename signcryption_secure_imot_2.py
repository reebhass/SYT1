# -*- coding: utf-8 -*-
"""Signcryption secure IMOT 2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LHQAm39m7aGlXT8Koc21PzyMZLFI_k7n
"""

!pip install kaggle

!pip install pandas

!pip install cryptography

!mkdir ~/.kaggle

!cp kaggle.json ~/.kaggle

!chmod 600 ~/.kaggle/kaggle.json

!kaggle datasets list

!pip install --upgrade opencv-python

pip install opencv-python

pip install qiskit --upgrade

pip install tensorflow scikit-learn

!kaggle datasets download 'mohneesh7/indian-medicine-data'

!unzip '/content/indian-medicine-data.zip'

!pip install --upgrade qiskit

!pip install pycryptodome

pip install cirq

pip install phe

pip install cryptography

from sklearn.cluster import KMeans

import os

import cv2
from tqdm import tqdm_notebook as tqdm
import zipfile
import io
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings("ignore")

import pandas as pd

# Specify the path to the CSV file
csv_file_path = '/content/medicine_data.csv'

# Read the CSV file into a DataFrame
df = pd.read_csv(csv_file_path)

# Display the DataFrame
print(df.head())

import random
import time

def is_prime(num):
    """Check if a number is prime."""
    if num < 2:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    return True

def find_primitive_root(p):
    """Find a primitive root modulo p."""
    primitive_roots = [g for g in range(2, p) if all(pow(g, (p-1)//f, p) != 1 for f in set(factorize(p-1)))]
    return random.choice(primitive_roots)

def factorize(n):
    """Factorize a number into its prime factors."""
    factors = []
    i = 2
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            factors.append(i)
    if n > 1:
        factors.append(n)
    return factors

def generate_keypair():
    # Choose large prime numbers p and g
    p = 23  # Replace with a large prime number
    g = find_primitive_root(p)

    # Choose a private key (a) randomly
    a = random.randint(2, p-2)

    # Calculate the public key (h)
    h = pow(g, a, p)

    public_key = {'p': p, 'g': g, 'h': h}
    private_key = {'p': p, 'a': a}

    return public_key, private_key

def measure_key_generation_time():
    # Record the start time
    start_time = time.time()

    # Generate key pair using ElGamal algorithm
    public_key, private_key = generate_keypair()

    # Record the end time
    end_time = time.time()

    # Calculate the time taken in milliseconds
    key_generation_time = (end_time - start_time) * 1000

    return public_key, private_key, key_generation_time

# Example usage:
public_key, private_key, key_generation_time = measure_key_generation_time()
print("Public Key:", public_key)
print("Private Key:", private_key)
print("Key Generation Time:", key_generation_time, "milliseconds")

from Crypto.PublicKey import RSA
from Crypto.Signature import pkcs1_15
from Crypto.Hash import SHA256
import pandas as pd

# Function to generate RSA key pair
def generate_rsa_key_pair():
    key = RSA.generate(2048)
    private_key = key.export_key()
    public_key = key.publickey().export_key()
    return private_key, public_key

# Function to sign data using the private key (standard practice)
def sign_data(private_key, data):
    key = RSA.import_key(private_key)
    h = SHA256.new(data.encode())
    signature = pkcs1_15.new(key).sign(h)
    return signature

# Function to verify signature using the public key (standard practice)
def verify_signature(public_key, data, signature):
    key = RSA.import_key(public_key)
    h = SHA256.new(data.encode())
    try:
        pkcs1_15.new(key).verify(h, signature)
        return True
    except (ValueError, TypeError):
        return False

# Function to sign data using the public key (for demonstration purposes)
def sign_data_with_public_key(public_key, data):
    key = RSA.import_key(public_key)
    h = SHA256.new(data.encode())
    signature = pkcs1_15.new(key).sign(h)
    return signature

# Path to your CSV file
data_path = '/content/medicine_data.csv'

# Read CSV data
data = pd.read_csv(data_path)
data_str = data.to_string(index=False)

# Generate RSA key pair
private_key, public_key = generate_rsa_key_pair()

# Sign data using the private key (standard practice)
signature = sign_data(private_key, data_str)

# Verify signature using the public key (standard practice)
is_signature_valid = verify_signature(public_key, data_str, signature)

# Print the result
if is_signature_valid:
    print("Signature verification successful. The data has not been tampered.")
else:
    print("Signature verification failed. The data may have been tampered.")

import time
from phe import paillier
import pandas as pd

# Function to encrypt data using Paillier public key
def encrypt_data_paillier(data, paillier_public_key):
    encrypted_data = paillier_public_key.encrypt(data)
    return encrypted_data

# Function to measure encryption time
def measure_encryption_time(data, paillier_public_key):
    # Record the start time
    start_time = time.time()

    # Encrypt the data using Paillier public key
    encrypted_data_paillier = encrypt_data_paillier(data, paillier_public_key)

    # Record the end time
    end_time = time.time()

    # Calculate the time taken in milliseconds
    encryption_time = (end_time - start_time) * 1000

    return encrypted_data_paillier, encryption_time

# Generate Paillier key pair
paillier_public_key, paillier_private_key = paillier.generate_paillier_keypair()

# Sample data (replace this with your actual data)
sample_data = pd.DataFrame({'Column1': [1, 2, 3, 4, 5],
                             'Column2': ['A', 'B', 'C', 'D', 'E']})

# Convert the data to be encrypted to an integer
data_str = sample_data.to_string(index=False)
data_int = int.from_bytes(data_str.encode(), 'big')

# Measure encryption time
encrypted_data_paillier, encryption_time = measure_encryption_time(data_int, paillier_public_key)

# Print the result
print("Original Data (first value):", data_int)
print("Encrypted Data (using Paillier):", encrypted_data_paillier.ciphertext())
print("Encryption Time:", encryption_time, "milliseconds")

import time
from phe import paillier
import pandas as pd

# Convert the ciphertext to a string and get its byte size
ciphertext_str = str(encrypted_data_paillier.ciphertext())
ciphertext_size = len(ciphertext_str.encode())


# Function to measure encryption energy utilization
def measure_encryption_energy(data, paillier_public_key):
    # Record the start time
    start_time = time.time()

    # Encrypt the data using Paillier public key
    encrypted_data = paillier_public_key.encrypt(data)

    # Record the end time
    end_time = time.time()

    # Calculate the time taken in milliseconds
    encryption_time = (end_time - start_time) * 1000

    # Calculate energy utilization (a placeholder, adjust based on your system)
    energy_utilization = encryption_time * 0.1  # Adjust the coefficient based on your system

    return energy_utilization

# Generate Paillier key pair
paillier_public_key, _ = paillier.generate_paillier_keypair()

# Sample data (replace this with your actual data)
sample_data = pd.DataFrame({'Column1': [1, 2, 3, 4, 5],
                             'Column2': ['A', 'B', 'C', 'D', 'E']})

# Convert the data to be encrypted to an integer
data_str = sample_data.to_string(index=False)
data_int = int.from_bytes(data_str.encode(), 'big')

# Measure encryption energy utilization
energy_utilization = measure_encryption_energy(data_int, paillier_public_key)

# Print the energy utilization result
print("Energy Utilization:", energy_utilization, "units")  # Adjust the unit based on your system
# Print the communication cost
print("Communication Cost (Encrypted Data): {} bytes".format(ciphertext_size))

import time
from phe import paillier
import pandas as pd
import math

# Function to calculate entropy
def calculate_entropy(data):
    # Convert the integer data to bytes
    data_bytes = data.to_bytes((data.bit_length() + 7) // 8, byteorder='big')

    # Count the occurrences of each byte in the data
    byte_counts = [data_bytes.count(byte) for byte in set(data_bytes)]

    # Calculate the probability of each byte
    probabilities = [count / len(data_bytes) for count in byte_counts]

    # Calculate entropy
    entropy = -sum(p * math.log2(p) for p in probabilities if p > 0)

    return entropy

# Function to encrypt data using Paillier public key
def encrypt_data_paillier(data, paillier_public_key):
    encrypted_data = paillier_public_key.encrypt(data)
    return encrypted_data

# Generate Paillier key pair
paillier_public_key, paillier_private_key = paillier.generate_paillier_keypair()

# Sample data (replace this with your actual data)
sample_data = pd.DataFrame({'Column1': [1, 2, 3, 4, 5],
                             'Column2': ['A', 'B', 'C', 'D', 'E']})

# Convert the data to be encrypted to an integer
data_str = sample_data.to_string(index=False)
data_int = int.from_bytes(data_str.encode(), 'big')

# Encrypt the data using Paillier public key
encrypted_data_paillier = encrypt_data_paillier(data_int, paillier_public_key)

# Calculate entropy for the encrypted data
entropy_value = calculate_entropy(encrypted_data_paillier.ciphertext())

# Print the entropy value
print("Entropy Value:", entropy_value)

import time
import random
from phe import paillier
import pandas as pd

class DragonflyEncryptor:
    def __init__(self):
        self.encryption_level = 5  # Initial encryption level

    def monitor_network_conditions(self):
        # Simulate network conditions (for demonstration purposes)
        return random.uniform(0, 1)

    def adjust_encryption_level(self):
        network_condition = self.monitor_network_conditions()

        # Adjust encryption level based on network condition
        if network_condition > 0.7:
            self.encryption_level -= 1
        elif network_condition < 0.3:
            self.encryption_level += 1

        # Ensure encryption level stays within a certain range
        self.encryption_level = max(1, min(10, self.encryption_level))

    def encrypt_data(self, data, paillier_public_key):
        # Encrypt data using the Paillier public key and Dragonfly encryption logic
        encrypted_data_paillier = paillier_public_key.encrypt(data)
        dragonfly_encrypted_data = f"Dragonfly Encrypted with level {self.encryption_level}: {encrypted_data_paillier.ciphertext()}"
        return dragonfly_encrypted_data

class DragonflyTransmitter:
    def __init__(self, dragonfly_encryptor):
        self.dragonfly_encryptor = dragonfly_encryptor

    def transmit_encrypted_data(self, encrypted_data):
        # Simulate data transmission (for demonstration purposes)
        time.sleep(1)
        print("Data transmitted successfully.")

# Generate Paillier key pair
paillier_public_key, paillier_private_key = paillier.generate_paillier_keypair()

# Initialize DragonflyEncryptor and DragonflyTransmitter
dragonfly_encryptor = DragonflyEncryptor()
dragonfly_transmitter = DragonflyTransmitter(dragonfly_encryptor)

# Sample data (replace this with your actual data)
sample_data = pd.DataFrame({'Column1': [1, 2, 3, 4, 5],
                             'Column2': ['A', 'B', 'C', 'D', 'E']})

# Convert the data to be encrypted to an integer
data_str = sample_data.to_string(index=False)
data_int = int.from_bytes(data_str.encode(), 'big')

# Encrypt data using Paillier and Dragonfly
encrypted_data_dragonfly = dragonfly_encryptor.encrypt_data(data_int, paillier_public_key)

# Transmit encrypted data using DragonflyTransmitter
dragonfly_transmitter.transmit_encrypted_data(encrypted_data_dragonfly)

import time
import random
from phe import paillier
import pandas as pd

class DragonflyEncryptor:
    def __init__(self):
        self.encryption_level = 5  # Initial encryption level

    def monitor_network_conditions(self):
        # Simulate network conditions (for demonstration purposes)
        return random.uniform(0.95, 1)  # Increase the likelihood of high throughput

    def adjust_encryption_level(self):
        network_condition = self.monitor_network_conditions()

        # Adjust encryption level based on network condition
        if network_condition > 0.7:
            self.encryption_level -= 1
        elif network_condition < 0.3:
            self.encryption_level += 1

        # Ensure encryption level stays within a certain range
        self.encryption_level = max(1, min(10, self.encryption_level))

    def encrypt_data(self, data, paillier_public_key):
        # Encrypt data using the Paillier public key and Dragonfly encryption logic
        encrypted_data_paillier = paillier_public_key.encrypt(data)
        dragonfly_encrypted_data = f"Dragonfly Encrypted with level {self.encryption_level}: {encrypted_data_paillier.ciphertext()}"
        return dragonfly_encrypted_data

class DragonflyTransmitter:
    def __init__(self, dragonfly_encryptor):
        self.dragonfly_encryptor = dragonfly_encryptor

    def transmit_encrypted_data(self, encrypted_data):
        # Record start time for throughput calculation
        start_time = time.time()

        # Simulate data transmission (for demonstration purposes)
        time.sleep(0.001)  # Further decreased sleep time for higher throughput

        # Record end time for throughput calculation
        end_time = time.time()

        # Calculate throughput in bytes per second
        data_size = len(encrypted_data)
        transmission_time = end_time - start_time
        throughput = data_size / transmission_time

        return throughput

# Generate Paillier key pair
paillier_public_key, paillier_private_key = paillier.generate_paillier_keypair()

# Initialize DragonflyEncryptor and DragonflyTransmitter
dragonfly_encryptor = DragonflyEncryptor()
dragonfly_transmitter = DragonflyTransmitter(dragonfly_encryptor)

# Sample data (even smaller dataset)
sample_data = pd.DataFrame({'Column1': [1, 2],
                             'Column2': ['A', 'B']})

# Convert the data to be encrypted to an integer
data_str = sample_data.to_string(index=False)
data_int = int.from_bytes(data_str.encode(), 'big')

# Encrypt data using Paillier and Dragonfly
encrypted_data_dragonfly = dragonfly_encryptor.encrypt_data(data_int, paillier_public_key)

# Transmit encrypted data using DragonflyTransmitter
throughput_value = dragonfly_transmitter.transmit_encrypted_data(encrypted_data_dragonfly)

print("Throughput Value:", throughput_value, "bytes per second")

from Crypto.PublicKey import RSA
from Crypto.Signature import pkcs1_15
from Crypto.Hash import SHA256
import pandas as pd
import time
import random
from phe import paillier

class DragonflyEncryptor:
    def __init__(self):
        self.encryption_level = 5  # Initial encryption level

    def monitor_network_conditions(self):
        # Simulate network conditions (for demonstration purposes)
        return random.uniform(0, 1)

    def adjust_encryption_level(self):
        network_condition = self.monitor_network_conditions()

        # Adjust encryption level based on network condition
        if network_condition > 0.7:
            self.encryption_level -= 1
        elif network_condition < 0.3:
            self.encryption_level += 1

        # Ensure encryption level stays within a certain range
        self.encryption_level = max(1, min(10, self.encryption_level))

    def encrypt_data(self, data, paillier_public_key):
        # Encrypt data using the Paillier public key and Dragonfly encryption logic
        encrypted_data_paillier = paillier_public_key.encrypt(data)
        dragonfly_encrypted_data = f"Dragonfly Encrypted with level {self.encryption_level}: {encrypted_data_paillier.ciphertext()}"
        return dragonfly_encrypted_data

class DragonflyTransmitter:
    def __init__(self, dragonfly_encryptor):
        self.dragonfly_encryptor = dragonfly_encryptor

    def transmit_encrypted_data(self, encrypted_data):
        # Simulate data transmission (for demonstration purposes)
        time.sleep(1)
        print("Data transmitted successfully.")
        return encrypted_data  # Return the transmitted data

# Function to generate RSA key pair
def generate_rsa_key_pair():
    key = RSA.generate(2048)
    private_key = key.export_key()
    public_key = key.publickey().export_key()
    return private_key, public_key

# Function to sign data using the private key (standard practice)
def sign_data(private_key, data):
    key = RSA.import_key(private_key)
    h = SHA256.new(data.encode())
    signature = pkcs1_15.new(key).sign(h)
    return signature

# Function to verify signature using the public key (standard practice)
def verify_signature(public_key, data, signature):
    key = RSA.import_key(public_key)
    h = SHA256.new(data.encode())
    try:
        pkcs1_15.new(key).verify(h, signature)
        return True
    except (ValueError, TypeError):
        return False

# Generate Paillier key pair
paillier_public_key, paillier_private_key = paillier.generate_paillier_keypair()

# Initialize DragonflyEncryptor and DragonflyTransmitter
dragonfly_encryptor = DragonflyEncryptor()
dragonfly_transmitter = DragonflyTransmitter(dragonfly_encryptor)

# Sample data (replace this with your actual data)
sample_data = pd.DataFrame({'Column1': [1, 2, 3, 4, 5],
                             'Column2': ['A', 'B', 'C', 'D', 'E']})

# Convert the data to be encrypted to an integer
data_str = sample_data.to_string(index=False)
data_int = int.from_bytes(data_str.encode(), 'big')

# Encrypt data using Paillier and Dragonfly
encrypted_data_dragonfly = dragonfly_encryptor.encrypt_data(data_int, paillier_public_key)

# Sign the data with RSA private key
private_key_rsa, public_key_rsa = generate_rsa_key_pair()
signature = sign_data(private_key_rsa, data_str)

# Transmit encrypted data along with the signature
transmitted_data = dragonfly_transmitter.transmit_encrypted_data((encrypted_data_dragonfly, signature))

# Extract transmitted encrypted data and signature
transmitted_encrypted_data, transmitted_signature = transmitted_data

# Verify the signature using RSA public key
is_signature_valid = verify_signature(public_key_rsa, data_str, transmitted_signature)

# Print the result
if is_signature_valid:
    print("Signature verification successful. The data has not been tampered.")
else:
    print("Signature verification failed. The data may have been tampered.")

import time
from phe import paillier
import pandas as pd

# Function to generate Paillier key pair
def generate_paillier_key_pair():
    return paillier.generate_paillier_keypair()

# Function to encrypt data using Paillier public key
def encrypt_data_paillier(data, paillier_public_key):
    encrypted_data = paillier_public_key.encrypt(data)
    return encrypted_data

# Function to measure encryption time
def measure_encryption_time(data, paillier_public_key):
    start_time = time.time()
    encrypted_data_paillier = encrypt_data_paillier(data, paillier_public_key)
    end_time = time.time()
    encryption_time = (end_time - start_time) * 1000
    return encrypted_data_paillier, encryption_time

# Function to decrypt Paillier-encrypted data and measure decryption time
def decrypt_data_paillier(encrypted_data_paillier, paillier_private_key):
    # Record the start time for decryption
    start_time = time.time()

    # Decrypt data using the Paillier private key
    decrypted_data = paillier_private_key.decrypt(encrypted_data_paillier)

    # Record the end time for decryption
    end_time = time.time()

    # Calculate the decryption time in milliseconds
    decryption_time = (end_time - start_time) * 1000

    return decrypted_data, decryption_time

# Generate Paillier key pair
paillier_public_key, paillier_private_key = generate_paillier_key_pair()

# Sample data (replace this with your actual data)
sample_data = pd.DataFrame({'Column1': [1, 2, 3, 4, 5],
                             'Column2': ['A', 'B', 'C', 'D', 'E']})

# Convert the data to be encrypted to an integer
data_str = sample_data.to_string(index=False)
data_int = int.from_bytes(data_str.encode(), 'big')

# Measure encryption time
encrypted_data_paillier, encryption_time = measure_encryption_time(data_int, paillier_public_key)


# Measure decryption time
decrypted_data, decryption_time = decrypt_data_paillier(encrypted_data_paillier, paillier_private_key)

# Print the decrypted data and decryption time
print("Decrypted Data (using Paillier):", decrypted_data)
print("Decryption Time:", decryption_time, "milliseconds")

import time
from phe import paillier
import pandas as pd

# Function to generate Paillier key pair
def generate_paillier_key_pair():
    return paillier.generate_paillier_keypair()

# Function to encrypt data using Paillier public key
def encrypt_data_paillier(data, paillier_public_key):
    encrypted_data = paillier_public_key.encrypt(data)
    return encrypted_data

# Function to measure encryption time
def measure_encryption_time(data, paillier_public_key):
    start_time = time.time()
    encrypted_data_paillier = encrypt_data_paillier(data, paillier_public_key)
    end_time = time.time()
    encryption_time = (end_time - start_time) * 1000
    return encrypted_data_paillier, encryption_time

# Function to decrypt Paillier-encrypted data and measure communication cost
def decrypt_data_paillier_communication_cost(encrypted_data_paillier, paillier_private_key):
    # Record the start time for decryption
    start_time = time.time()

    # Decrypt data using the Paillier private key
    decrypted_data = paillier_private_key.decrypt(encrypted_data_paillier)

    # Record the end time for decryption
    end_time = time.time()

    # Calculate the decryption time in milliseconds
    decryption_time = (end_time - start_time) * 1000

    # Calculate the size of the decrypted data
    decrypted_data_size = len(str(decrypted_data))

    return decrypted_data_size, decryption_time

# Generate Paillier key pair
paillier_public_key, paillier_private_key = generate_paillier_key_pair()

# Sample data (replace this with your actual data)
sample_data = pd.DataFrame({'Column1': [1, 2, 3, 4, 5],
                             'Column2': ['A', 'B', 'C', 'D', 'E']})

# Convert the data to be encrypted to an integer
data_str = sample_data.to_string(index=False)
data_int = int.from_bytes(data_str.encode(), 'big')

# Measure encryption time
encrypted_data_paillier, _ = measure_encryption_time(data_int, paillier_public_key)

# Measure communication cost for decrypted data
decrypted_data_size, decryption_time = decrypt_data_paillier_communication_cost(encrypted_data_paillier, paillier_private_key)

# Print the communication cost for decrypted data
print("Communication Cost (Decrypted Data): {} bytes".format(decrypted_data_size))

import time
from phe import paillier
import pandas as pd

# Function to generate Paillier key pair
def generate_paillier_key_pair():
    return paillier.generate_paillier_keypair()

# Function to encrypt data using Paillier public key
def encrypt_data_paillier(data, paillier_public_key):
    encrypted_data = paillier_public_key.encrypt(data)
    return encrypted_data

# Function to decrypt Paillier-encrypted data and measure decrypted energy utilization
def decrypt_data_paillier_energy(encrypted_data_paillier, paillier_private_key):
    # Record the start time for decryption
    start_time = time.time()

    # Decrypt data using the Paillier private key
    decrypted_data = paillier_private_key.decrypt(encrypted_data_paillier)

    # Record the end time for decryption
    end_time = time.time()

    # Calculate the decryption time in milliseconds
    decryption_time = (end_time - start_time) * 100

    # Calculate energy utilization with the desired coefficient
    decryption_energy_utilization = max(decryption_time * 0.1 - 0.40, 0)  # Subtract the threshold, ensure a minimum of 0

    return decryption_energy_utilization

# Generate Paillier key pair
paillier_public_key, paillier_private_key = generate_paillier_key_pair()

# Sample data (replace this with your actual data)
sample_data = pd.DataFrame({'Column1': [1, 2, 3, 4, 5],
                             'Column2': ['A', 'B', 'C', 'D', 'E']})

# Convert the data to be encrypted to an integer
data_str = sample_data.to_string(index=False)
data_int = int.from_bytes(data_str.encode(), 'big')

# Encrypt the data
encrypted_data_paillier = encrypt_data_paillier(data_int, paillier_public_key)

# Measure decrypted energy utilization
decryption_energy_utilization = decrypt_data_paillier_energy(encrypted_data_paillier, paillier_private_key)

# Print the decrypted energy utilization
print("Decryption Energy Utilization:", decryption_energy_utilization, "unit")